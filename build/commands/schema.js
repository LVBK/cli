'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSchemaToExtJson = saveSchemaToExtJson;
exports.createSchema = createSchema;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _extension = require('../services/extension');

var _template = require('../services/template');

var _user_messages = require('../user_messages');

var _user_messages2 = _interopRequireDefault(_user_messages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function saveSchemaToExtJson(schemaName, callback) {
  _async2.default.waterfall([_extension.loadExtensionJsonCallback, (extension, done) => {
    /* eslint no-param-reassign: 0 */
    const names = _lodash2.default.get(extension, 'dataSchemas', []).map(s => s.name);
    if (_lodash2.default.includes(names, schemaName)) {
      done(new Error(_user_messages2.default.schema.add.alreadyExists(schemaName)));
    } else {
      done(null, extension);
    }
  }, (extension, done) => {
    const schema = {
      name: schemaName,
      // extension.json should specify all paths with forward slashes regardless of OS:
      path: `server/data-schemas/${schemaName}.json`
    };
    if (extension.dataSchemas) extension.dataSchemas.push(schema);else extension.dataSchemas = [schema];
    (0, _extension.saveExtensionJsonCallback)(extension, done);
  }], callback);
}

function createSchema(schemaName, callback) {
  const root = (0, _extension.ensureInExtensionDir)();
  let schemaPath;

  _async2.default.series([done => saveSchemaToExtJson(schemaName, done), done => (0, _mkdirp2.default)(_path2.default.join(root, 'server', 'data-schemas'), done), done => {
    const template = (0, _template.load)('./schema/schema.json.template', { schemaName });
    schemaPath = _path2.default.join(root, 'server', 'data-schemas', `${schemaName}.json`);
    _fs2.default.writeFile(schemaPath, template, 'utf8', done);
  }], err => callback(err, schemaPath ? _path2.default.relative(root, schemaPath) : null));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tYW5kcy9zY2hlbWEuanMiXSwibmFtZXMiOlsic2F2ZVNjaGVtYVRvRXh0SnNvbiIsImNyZWF0ZVNjaGVtYSIsInNjaGVtYU5hbWUiLCJjYWxsYmFjayIsImFzeW5jIiwid2F0ZXJmYWxsIiwibG9hZEV4dGVuc2lvbkpzb25DYWxsYmFjayIsImV4dGVuc2lvbiIsImRvbmUiLCJuYW1lcyIsIl8iLCJnZXQiLCJtYXAiLCJzIiwibmFtZSIsImluY2x1ZGVzIiwiRXJyb3IiLCJtc2ciLCJzY2hlbWEiLCJhZGQiLCJhbHJlYWR5RXhpc3RzIiwicGF0aCIsImRhdGFTY2hlbWFzIiwicHVzaCIsInJvb3QiLCJzY2hlbWFQYXRoIiwic2VyaWVzIiwiam9pbiIsInRlbXBsYXRlIiwiZnMiLCJ3cml0ZUZpbGUiLCJlcnIiLCJyZWxhdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFpQmdCQSxtQixHQUFBQSxtQjtRQTRCQUMsWSxHQUFBQSxZOztBQTdDaEI7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUtBOztBQUVBOzs7Ozs7QUFHTyxTQUFTRCxtQkFBVCxDQUE2QkUsVUFBN0IsRUFBeUNDLFFBQXpDLEVBQW1EO0FBQ3hEQyxrQkFBTUMsU0FBTixDQUFnQixDQUNkQyxvQ0FEYyxFQUdkLENBQUNDLFNBQUQsRUFBWUMsSUFBWixLQUFxQjtBQUNuQjtBQUNBLFVBQU1DLFFBQVFDLGlCQUFFQyxHQUFGLENBQU1KLFNBQU4sRUFBaUIsYUFBakIsRUFBZ0MsRUFBaEMsRUFBb0NLLEdBQXBDLENBQXdDQyxLQUFLQSxFQUFFQyxJQUEvQyxDQUFkO0FBQ0EsUUFBSUosaUJBQUVLLFFBQUYsQ0FBV04sS0FBWCxFQUFrQlAsVUFBbEIsQ0FBSixFQUFtQztBQUNqQ00sV0FBSyxJQUFJUSxLQUFKLENBQVVDLHdCQUFJQyxNQUFKLENBQVdDLEdBQVgsQ0FBZUMsYUFBZixDQUE2QmxCLFVBQTdCLENBQVYsQ0FBTDtBQUNELEtBRkQsTUFFTztBQUNMTSxXQUFLLElBQUwsRUFBV0QsU0FBWDtBQUNEO0FBQ0YsR0FYYSxFQWFkLENBQUNBLFNBQUQsRUFBWUMsSUFBWixLQUFxQjtBQUNuQixVQUFNVSxTQUFTO0FBQ2JKLFlBQU1aLFVBRE87QUFFYjtBQUNBbUIsWUFBTyx1QkFBc0JuQixVQUFXO0FBSDNCLEtBQWY7QUFLQSxRQUFJSyxVQUFVZSxXQUFkLEVBQTJCZixVQUFVZSxXQUFWLENBQXNCQyxJQUF0QixDQUEyQkwsTUFBM0IsRUFBM0IsS0FDS1gsVUFBVWUsV0FBVixHQUF3QixDQUFDSixNQUFELENBQXhCO0FBQ0wsOENBQTBCWCxTQUExQixFQUFxQ0MsSUFBckM7QUFDRCxHQXRCYSxDQUFoQixFQXdCRUwsUUF4QkY7QUF5QkQ7O0FBRU0sU0FBU0YsWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ2pELFFBQU1xQixPQUFPLHNDQUFiO0FBQ0EsTUFBSUMsVUFBSjs7QUFFQXJCLGtCQUFNc0IsTUFBTixDQUFhLENBQ1hsQixRQUFRUixvQkFBb0JFLFVBQXBCLEVBQWdDTSxJQUFoQyxDQURHLEVBR1hBLFFBQVEsc0JBQU9hLGVBQUtNLElBQUwsQ0FBVUgsSUFBVixFQUFnQixRQUFoQixFQUEwQixjQUExQixDQUFQLEVBQWtEaEIsSUFBbEQsQ0FIRyxFQUtYQSxRQUFRO0FBQ04sVUFBTW9CLFdBQVcsb0JBQUssK0JBQUwsRUFBc0MsRUFBRTFCLFVBQUYsRUFBdEMsQ0FBakI7QUFDQXVCLGlCQUFhSixlQUFLTSxJQUFMLENBQVVILElBQVYsRUFBZ0IsUUFBaEIsRUFBMEIsY0FBMUIsRUFBMkMsR0FBRXRCLFVBQVcsT0FBeEQsQ0FBYjtBQUNBMkIsaUJBQUdDLFNBQUgsQ0FBYUwsVUFBYixFQUF5QkcsUUFBekIsRUFBbUMsTUFBbkMsRUFBMkNwQixJQUEzQztBQUNELEdBVFUsQ0FBYixFQVdFdUIsT0FBTzVCLFNBQVM0QixHQUFULEVBQWNOLGFBQWFKLGVBQUtXLFFBQUwsQ0FBY1IsSUFBZCxFQUFvQkMsVUFBcEIsQ0FBYixHQUErQyxJQUE3RCxDQVhUO0FBWUQiLCJmaWxlIjoic2NoZW1hLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgYXN5bmMgZnJvbSAnYXN5bmMnO1xyXG5pbXBvcnQgbWtkaXJwIGZyb20gJ21rZGlycCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGxvYWRFeHRlbnNpb25Kc29uQ2FsbGJhY2ssXHJcbiAgc2F2ZUV4dGVuc2lvbkpzb25DYWxsYmFjayxcclxuICBlbnN1cmVJbkV4dGVuc2lvbkRpcixcclxufSBmcm9tICcuLi9zZXJ2aWNlcy9leHRlbnNpb24nO1xyXG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnLi4vc2VydmljZXMvdGVtcGxhdGUnO1xyXG5cclxuaW1wb3J0IG1zZyBmcm9tICcuLi91c2VyX21lc3NhZ2VzJztcclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVNjaGVtYVRvRXh0SnNvbihzY2hlbWFOYW1lLCBjYWxsYmFjaykge1xyXG4gIGFzeW5jLndhdGVyZmFsbChbXHJcbiAgICBsb2FkRXh0ZW5zaW9uSnNvbkNhbGxiYWNrLFxyXG5cclxuICAgIChleHRlbnNpb24sIGRvbmUpID0+IHtcclxuICAgICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXHJcbiAgICAgIGNvbnN0IG5hbWVzID0gXy5nZXQoZXh0ZW5zaW9uLCAnZGF0YVNjaGVtYXMnLCBbXSkubWFwKHMgPT4gcy5uYW1lKTtcclxuICAgICAgaWYgKF8uaW5jbHVkZXMobmFtZXMsIHNjaGVtYU5hbWUpKSB7XHJcbiAgICAgICAgZG9uZShuZXcgRXJyb3IobXNnLnNjaGVtYS5hZGQuYWxyZWFkeUV4aXN0cyhzY2hlbWFOYW1lKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvbmUobnVsbCwgZXh0ZW5zaW9uKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAoZXh0ZW5zaW9uLCBkb25lKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHtcclxuICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxyXG4gICAgICAgIC8vIGV4dGVuc2lvbi5qc29uIHNob3VsZCBzcGVjaWZ5IGFsbCBwYXRocyB3aXRoIGZvcndhcmQgc2xhc2hlcyByZWdhcmRsZXNzIG9mIE9TOlxyXG4gICAgICAgIHBhdGg6IGBzZXJ2ZXIvZGF0YS1zY2hlbWFzLyR7c2NoZW1hTmFtZX0uanNvbmAsXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChleHRlbnNpb24uZGF0YVNjaGVtYXMpIGV4dGVuc2lvbi5kYXRhU2NoZW1hcy5wdXNoKHNjaGVtYSk7XHJcbiAgICAgIGVsc2UgZXh0ZW5zaW9uLmRhdGFTY2hlbWFzID0gW3NjaGVtYV07XHJcbiAgICAgIHNhdmVFeHRlbnNpb25Kc29uQ2FsbGJhY2soZXh0ZW5zaW9uLCBkb25lKTtcclxuICAgIH0sXHJcbiAgXSxcclxuICAgIGNhbGxiYWNrKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYShzY2hlbWFOYW1lLCBjYWxsYmFjaykge1xyXG4gIGNvbnN0IHJvb3QgPSBlbnN1cmVJbkV4dGVuc2lvbkRpcigpO1xyXG4gIGxldCBzY2hlbWFQYXRoO1xyXG5cclxuICBhc3luYy5zZXJpZXMoW1xyXG4gICAgZG9uZSA9PiBzYXZlU2NoZW1hVG9FeHRKc29uKHNjaGVtYU5hbWUsIGRvbmUpLFxyXG5cclxuICAgIGRvbmUgPT4gbWtkaXJwKHBhdGguam9pbihyb290LCAnc2VydmVyJywgJ2RhdGEtc2NoZW1hcycpLCBkb25lKSxcclxuXHJcbiAgICBkb25lID0+IHtcclxuICAgICAgY29uc3QgdGVtcGxhdGUgPSBsb2FkKCcuL3NjaGVtYS9zY2hlbWEuanNvbi50ZW1wbGF0ZScsIHsgc2NoZW1hTmFtZSB9KTtcclxuICAgICAgc2NoZW1hUGF0aCA9IHBhdGguam9pbihyb290LCAnc2VydmVyJywgJ2RhdGEtc2NoZW1hcycsIGAke3NjaGVtYU5hbWV9Lmpzb25gKTtcclxuICAgICAgZnMud3JpdGVGaWxlKHNjaGVtYVBhdGgsIHRlbXBsYXRlLCAndXRmOCcsIGRvbmUpO1xyXG4gICAgfSxcclxuICBdLFxyXG4gICAgZXJyID0+IGNhbGxiYWNrKGVyciwgc2NoZW1hUGF0aCA/IHBhdGgucmVsYXRpdmUocm9vdCwgc2NoZW1hUGF0aCkgOiBudWxsKSk7XHJcbn1cclxuIl19